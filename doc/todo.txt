1 - DATATYPE MANAGEMENT

. look for package creation/import code for every datatype to find out where a transcoding of data is needed:
  - object relation(s), xml block, etc... -> we need to tranform object ids into their remote equivalent
  - binary datatypes -> we need better support than fromstring/tostring do natively
  - ezpage: ???
  - all other datatypes that do not serialize to a single scalar value -> use structured json instead of toString() format

. status:
  - export+import of object relations(s) and binary files: ok with remote ids, use json arrays for non-remote ids too
  - export+import to be done for xml block
  - export+import to be done for ezauthor
  - export+import to be done for ezuser
  - export+import to be done for ezenum ?
  - ezstarrating, ezgmaplocation, ezpage ?
  - all other types that do not serialize to a single scalar value

. add support for sending in object creation/modification requests the original timestamp and remote_id of creator user;
  - add support for importing that data into target system


2 - EVENTS

. source server: finish missing events:
  - swap
  - move (test it)
  - change main node (test it)

. source server: when sending an event of type delete (no trash), we should also remove from local queue all pending events for the given object (and maybe warn user too before doing so)

. source server: logical bug: if local obj has been deleted (no trash) and there are pending publication events for it, we will not be able to sync them it anymore
  => warn editor (on delete or on sync?), remove pending events, or... ?


3 - REST API

. target server: finish actions
  - set obj state

. test all actions

. target server: make sure content creation triggers are used on target server too, to make server chaining possible


4 - INTERFACE

. source server: finish js code used by ajax calls for ezwt (it misses checking of return value, alert, changing icon state)

. source server: proper policy checking before allowing sync calls (ok in "feed" view; remains to be seen in ezjscore call)

. source server: settle on naming conventions (user-side), rewrite all text labels in templates

. source server: settle on set of sync icons: needs to sync, is syncing, no need to sync

. settle on list of cols available in feed view and in dashboard block; make sure that it works ok for items relating to deleted nodes (showing enough info)

. source server: reset all calls to ez18n to use a single namespace: "contentstating"

. source server: in wt tpl, try to filter out items in syncing status (show a different icon, do not allow to sync)

. source server: rework dashboard block so that it lists nodes instead of sync events
  note that we will have problems with deleted objects not being shown there

5 - MISC

. create some documentation: a table of all events, and for each one:
  - the nodes affected (in terms of feeds that will have to be notified)
  - the nodes affected (in terms of which nodes in the ezwt toolbar should show a "sync" icon)
  - details of complex cases (where this logic is not straight)


Phase 1.5 (move to phase 2 ?)

. source server: allow admin user to delete events in pending status too (after confirmation dialog or via cli script)

. source server: finish cli scripts that reset and initialize feeds. Also creates a publish event for all of content (same az efindexcontents)

. source server: add confirmation dialogs when deleting events / resetting feeds

. source server: add an extra per-feed ini parameter that decides whether content creation/modification dates on targets are kept in sync with source or sync event execution date is used instead

. dependency tracking:
  - all events should not have a pending create event for any of their parents (or they cannot be synced)
  - obj relations?
  - set section: should not have a pending set section for one of its parents (nb: even for 2ndary locations? test it)
  - hide: should not have a pending set section for one of its parents

. source server: refactor diffing of content in separate classes


Phase 2:

. rest server: fix bug: when using auto_auth filter, eZ sends 2 or 3 session cookies
. source server: allow sync items that fail 3 consecutive sync attempts to be set to "suspended" state
. source server: allow finer grained permissions (sync per feed)
. source server: cronjob that passes and removes/resets sync items that have been in sync status for too long
. source server: coalescing of sync events
. add a sync-to-localhost transport class, that copies data to separate content trees without going through rest calls
. source server: graceful degradation: allow wt button to sync with no js available by posting to contentstaging/syncnode
. source server: add extended attr. filter: given target feed id, get for every node the sync events pending by using aggregate sql function bit_and
. source server: use some "struct" classes to hold data for every type of stagingevent instead of plain arrays, to make the kind of data expected more evident
. for ezp 4.6, add also to the media gallery (and to users?) the new subtab added to object view for admin2 design
  - also maybe add extra items to context menus?
. source server: finish case where a move event becomes a create for a target server (create all versions, all languages)
. verify events that need to happen before action: are we sure that after this event action can not be skipped (eg: because of some perms checking or some other events in chain?)
  Try to move them to "after" (eventually, patch operations: content/hide, ), or set up a two-phase logic:
  1. before action events sets up the sync-event in an "unconfirmed" state
  2. after action event moves the sync-event to "confirmed" state
. rest protocol: have source server use the "Fields" param in query string to limit data returned by target server and reduce bandwidth usage
. refactor error condition management so that we get both a number and a string across the whole chain from the transport layer to the templates
. fix: sending hide event sends an empty array encoded as json (same for setsection events). can we avoid this?
. use the same class to encode/decode objects on both source and target


Phase 3:

. add opportunity to add custom filters on outgoing events (pre-queueing, at-sending, more?)
. add script that inits a feed with a non-empty target server (creates init-node events based eg. on node paths)
. add setup-wizard to create and init targets
. allow targets to be in "auto" mode, ie. sync events as soon as they are created, and in "delayed" mode too (via cronjob)
. add xmlrpc and soap service layers
. review separation of checking inputs between controllers and models
. review usage of return codes vs. exceptions
